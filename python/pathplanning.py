# -*- coding: utf-8 -*-
"""A*_livecoding.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dzGtrr6Wbb2-qv6fILutd4wSmGNI3hJC
"""

def is_colab():
    try:
        import google.colab
        return True
    except ImportError:
        return False
on_colab = is_colab()

if on_colab:
  import imageio
  import requests
  from IPython.display import Image, display
  import pathlib
  # 1. Construct the raw GitHub URL
  url = (
      "https://raw.githubusercontent.com/"
      "Annika-wyt/pink_summer_camp_robotics/main/maps/sml.pgm"
  )
  # 2. Fetch the file content
  response = requests.get(url)
  response.raise_for_status()  # makes sure we catch errors
  # 3. Save it locally (optional, but neat)
  local_path = pathlib.Path("/content/sml.pgm")
  local_path.write_bytes(response.content)
  # 4. Read and display using imageio
  img = imageio.imread(local_path)
  print(f"Image shape: {img.shape}, dtype: {img.dtype}")
  # 5. Display inline in the notebook
  # Convert to a standard image format (e.g. PNG) for display
  import matplotlib.pyplot as plt
  plt.imshow(img, cmap="gray")
  plt.axis("off")
  plt.title("Loaded .pgm Image from GitHub")
  plt.show()



"""# Map Pre Processing for path planning"""

if on_colab:
  import cv2
  import matplotlib.pyplot as plt
  import numpy as np
  import math
  import random
  import pandas as pd
  import matplotlib.animation as animation
  from IPython.display import HTML
  import heapq

# STEP 1: Load map image (grayscale)
if on_colab:
  map_img = img

# STEP 2: Preprocess map into occupancy grid
def preprocess_map(image, threshold=200):
    grid = np.zeros_like(image, dtype=np.int8)
    grid[image > threshold] = 1      # Free space
    grid[image < 50] = 0             # Obstacle
    grid[(image >= 50) & (image <= threshold)] = -1  # Unknown
    return grid

if on_colab:
  occupancy_grid = preprocess_map(map_img)

# STEP 3: Downsample to coarser grid
def grid_from_occupancy(occ_grid, resolution=10):
    h, w = occ_grid.shape
    h_new, w_new = h // resolution, w // resolution
    grid = np.zeros((h_new, w_new), dtype=np.int8)
    for i in range(h_new):
        for j in range(w_new):
            block = occ_grid[i*resolution:(i+1)*resolution, j*resolution:(j+1)*resolution]
            vals, counts = np.unique(block, return_counts=True)
            grid[i, j] = vals[np.argmax(counts)]
    return grid

if on_colab:
  downsampled_grid = grid_from_occupancy(occupancy_grid, resolution=10)

# STEP 4: Visualize result overlay
def draw_grid_on_map(original_img, grid, resolution=10, color=(0, 255, 0)):
    vis_map = cv2.cvtColor(original_img, cv2.COLOR_GRAY2BGR)
    for i in range(grid.shape[0]):
        for j in range(grid.shape[1]):
            if grid[i, j] == 1:
                y, x = i * resolution, j * resolution
                cv2.rectangle(vis_map, (x, y), (x + resolution - 1, y + resolution - 1), color, 1)
    return vis_map

if on_colab:
  overlay_img = draw_grid_on_map(map_img, downsampled_grid, resolution=10)
  plt.figure(figsize=(10, 10))
  plt.imshow(cv2.cvtColor(overlay_img, cv2.COLOR_BGR2RGB))
  plt.title("Grid Overlay on Original Map")
  plt.axis("off")
  plt.show()

# Mark 0 = free to go, 1 = not free (obstacle or unknown)
def binary_traversable_grid(grid):
    """Convert occupancy grid to binary traversability grid: 0 = free, 1 = not free."""
    binary_grid = np.ones_like(grid, dtype=np.uint8)
    binary_grid[grid == 1] = 0  # Mark free space as 0
    return binary_grid

# Apply the conversion
if on_colab:
  traversable_grid = binary_traversable_grid(downsampled_grid)

# Display as a scrollable HTML table
if on_colab:
  from IPython.display import display
  display(pd.DataFrame(traversable_grid))

  traversable_grid.shape

if on_colab:
  plt.figure(figsize=(10, 6))
  plt.title("Traversable Grid (0=Free, 1=Blocked)")
  plt.imshow(traversable_grid, cmap='gray')
  plt.colorbar(label="0 = Free, 1 = Blocked")
  plt.show()

if on_colab:
  # Let's inspect image intensity histogram to pick a better threshold
  plt.figure(figsize=(8, 4))
  plt.hist(map_img.ravel(), bins=256, range=(0, 256), color='blue', alpha=0.7)
  plt.title("Histogram of Pixel Intensities")
  plt.xlabel("Pixel Intensity")
  plt.ylabel("Frequency")
  plt.grid(True)
  plt.show()

# Apply refined thresholding logic for second image
def preprocess_map_strict_white_only(image, free_threshold=250):
    """
    Mark only pure white as free space.
    - Pixels >= free_threshold â†’ free (1)
    - Pixels < free_threshold â†’ obstacle (0)
    """
    grid = np.zeros_like(image, dtype=np.int8)
    grid[image >= free_threshold] = 1  # Only pure white is free
    return grid

if on_colab:
  # Process second image
  occupancy_grid_2 = preprocess_map_strict_white_only(map_img, free_threshold=250)
  downsampled_grid_2 = grid_from_occupancy(occupancy_grid_2, resolution=10)
  traversable_grid_2 = binary_traversable_grid(downsampled_grid_2)

  # Show binary traversability map
  plt.figure(figsize=(10, 6))
  plt.title("Traversable Grid from Second Image (0=Free, 1=Blocked)")
  plt.imshow(traversable_grid_2, cmap='gray')
  plt.colorbar(label="0 = Free, 1 = Blocked")
  plt.show()

"""## A*"""

# Define Node class and astar function
class Node():
    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position
        self.g = 0
        self.h = 0
        self.f = 0

    def __eq__(self, other):
      '''
      The __eq__ method in Python is a special method that defines equality
      behavior for objects of a class when using the == operator.
      This means: Two Node objects will be considered equal (==) if their
      position attributes are equal, even if all other attributes
      (like parent, g, h, f) are different.
      '''
      return self.position == other.position


def astar(maze, start, end):
    start_node = Node(None, start)
    end_node = Node(None, end)
    open_list = [start_node]
    closed_list = []
    print(f"end {end}")
    print(f"end_node {end_node}")

    while open_list:
        current_node = min(open_list, key=lambda node: node.f)
        open_list.remove(current_node)
        closed_list.append(current_node)

        if current_node == end_node:
            path = []
            current = current_node
            while current:
                path.append(current.position)
                current = current.parent
            return path[::-1]

        for move in [(0, -1), (0, 1), (-1, 0), (1, 0),
                     (-1, -1), (-1, 1), (1, -1), (1, 1)]:
            node_position = (current_node.position[0] + move[0], current_node.position[1] + move[1])

            if not (0 <= node_position[0] < len(maze)) or not (0 <= node_position[1] < len(maze[0])):
                continue
            if maze[node_position[0]][node_position[1]] != 0:
                continue

            new_node = Node(current_node, node_position)

            if new_node in closed_list:
                continue

            new_node.g = current_node.g + 1
            new_node.h = (new_node.position[0] - end_node.position[0]) ** 2 + \
                         (new_node.position[1] - end_node.position[1]) ** 2
            new_node.f = new_node.g + new_node.h

            if any(open_node for open_node in open_list if new_node == open_node and new_node.g > open_node.g):
                continue

            open_list.append(new_node)

def print_map(matrix, start, end, path):
    rows, cols = len(matrix), len(matrix[0])
    map_to_print = [['â¬œ' if cell == 0 else 'â¬›' for cell in row] for row in matrix]

    if path:
        for pos in path:
            if pos != start and pos != end:
                map_to_print[pos[0]][pos[1]] = 'ðŸŸ¦'

    map_to_print[start[0]][start[1]] = 'ðŸŸ©'
    map_to_print[end[0]][end[1]] = 'ðŸŸ¥'

    for row in map_to_print:
        print(''.join(row))

if on_colab:
  # Now try A* execution on random points
  free_coords = list(zip(*np.where(traversable_grid_2 == 0)))
  start, end = random.sample(free_coords, 2)

  # good example for start-end coordinates:

  # start = (np.int64(37), np.int64(30))
  # end = (np.int64(23), np.int64(39))

  path = astar(traversable_grid_2.tolist(), start, end)
  print(path)
  print("Start:", start)
  print("End:", end)
  print_map(traversable_grid_2.tolist(), start, end, path)

