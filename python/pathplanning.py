#! /usr/bin/env python3
# -*- coding: utf-8 -*-
"""pathplanning.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WAvLXYhlGDg9QhJy2sAfVS4fuGKQRhZw

# Map Pre Processing for path planning
"""

def is_google_colab():
    try:
        import math
        import random
        import heapq
        import numpy as np
        import cv2
        import matplotlib.pyplot as plt
        import pandas as pd
        import matplotlib.animation as animation
        from IPython.display import HTML
        # Display as a scrollable HTML table
        from IPython.display import display
        from google.colab import drive
        drive.mount('/content/drive')

        # STEP 1: Load map image (grayscale)
        # ADJUST THE PATH BELOW ACCORDING TO YOUR GOOGLE DRIVE STRUCTRURE
        map_path = "/content/drive/MyDrive/PINK/Pink Camps/2025 Summer Camp/Robotics & AI Camp 2025/Robotics workshop/my_map.pgm"
        map_img = cv2.imread(map_path, cv2.IMREAD_GRAYSCALE)
        return True
    except ImportError:
        return False

is_google_colab()

# STEP 2: Preprocess map into occupancy grid
def preprocess_map(image, threshold=200):
    grid = np.zeros_like(image, dtype=np.int8)
    grid[image > threshold] = 1      # Free space
    grid[image < 50] = 0             # Obstacle
    grid[(image >= 50) & (image <= threshold)] = -1  # Unknown
    return grid

if is_google_colab():
    occupancy_grid = preprocess_map(map_img)

# STEP 3: Downsample to coarser grid
def grid_from_occupancy(occ_grid, resolution=10):
    h, w = occ_grid.shape
    h_new, w_new = h // resolution, w // resolution
    grid = np.zeros((h_new, w_new), dtype=np.int8)
    for i in range(h_new):
        for j in range(w_new):
            block = occ_grid[i*resolution:(i+1)*resolution, j*resolution:(j+1)*resolution]
            vals, counts = np.unique(block, return_counts=True)
            grid[i, j] = vals[np.argmax(counts)]
    return grid

if is_google_colab():
    downsampled_grid = grid_from_occupancy(occupancy_grid, resolution=10)

# STEP 4: Visualize result overlay
def draw_grid_on_map(original_img, grid, resolution=10, color=(0, 255, 0)):
    vis_map = cv2.cvtColor(original_img, cv2.COLOR_GRAY2BGR)
    for i in range(grid.shape[0]):
        for j in range(grid.shape[1]):
            if grid[i, j] == 1:
                y, x = i * resolution, j * resolution
                cv2.rectangle(vis_map, (x, y), (x + resolution - 1, y + resolution - 1), color, 1)
    return vis_map

if is_google_colab():
    overlay_img = draw_grid_on_map(map_img, downsampled_grid, resolution=10)
    plt.figure(figsize=(10, 10))
    plt.imshow(cv2.cvtColor(overlay_img, cv2.COLOR_BGR2RGB))
    plt.title("Grid Overlay on Original Map")
    plt.axis("off")
    plt.show()

# Mark 0 = free to go, 1 = not free (obstacle or unknown)
def binary_traversable_grid(grid):
    """Convert occupancy grid to binary traversability grid: 0 = free, 1 = not free."""
    binary_grid = np.ones_like(grid, dtype=np.uint8)
    binary_grid[grid == 1] = 0  # Mark free space as 0
    return binary_grid

# Apply the conversion
if is_google_colab():
    traversable_grid = binary_traversable_grid(downsampled_grid)
    display(pd.DataFrame(traversable_grid))
    traversable_grid.shape

if is_google_colab():
    plt.figure(figsize=(10, 6))
    plt.title("Traversable Grid (0=Free, 1=Blocked)")
    plt.imshow(traversable_grid, cmap='gray')
    plt.colorbar(label="0 = Free, 1 = Blocked")
    plt.show()

if is_google_colab():
    # Let's inspect image intensity histogram to pick a better threshold
    plt.figure(figsize=(8, 4))
    plt.hist(map_img.ravel(), bins=256, range=(0, 256), color='blue', alpha=0.7)
    plt.title("Histogram of Pixel Intensities")
    plt.xlabel("Pixel Intensity")
    plt.ylabel("Frequency")
    plt.grid(True)
    plt.show()

# Apply refined thresholding logic for second image
def preprocess_map_strict_white_only(image, free_threshold=250):
    """
    Mark only pure white as free space.
    - Pixels >= free_threshold â†’ free (1)
    - Pixels < free_threshold â†’ obstacle (0)
    """
    grid = np.zeros_like(image, dtype=np.int8)
    grid[image >= free_threshold] = 1  # Only pure white is free
    return grid


if is_google_colab():
    # Process second image
    occupancy_grid_2 = preprocess_map_strict_white_only(map_img, free_threshold=250)
    downsampled_grid_2 = grid_from_occupancy(occupancy_grid_2, resolution=10)
    traversable_grid_2 = binary_traversable_grid(downsampled_grid_2)

    # Show binary traversability map
    plt.figure(figsize=(10, 6))
    plt.title("Traversable Grid from Second Image (0=Free, 1=Blocked)")
    plt.imshow(traversable_grid_2, cmap='gray')
    plt.colorbar(label="0 = Free, 1 = Blocked")
    plt.show()

"""# Peth Planning Strategies

| Algorithm | Type             | Path Shape      | Characteristics                        |
|----------|------------------|------------------|----------------------------------------|
| **A\***   | Grid-based       | Zig-zag, optimal | Deterministic, fast                    |
| **RRT\*** | Sampling-based   | Tree, random     | Good in high-dimensional spaces        |
| **APF**   | Gradient-based   | Smooth, curved   | Reactive, intuitive, non-optimal       |
| **D\***   | Grid-based       | Zig-zag, adaptive| Replans efficiently in dynamic maps    |

## A*
"""

# Define Node class and astar function as provided earlier
class Node():
    def __init__(self, parent=None, position=None):
        self.parent = parent
        self.position = position
        self.g = 0
        self.h = 0
        self.f = 0

    def __eq__(self, other):
        return self.position == other.position

def astar(maze, start, end):
    start_node = Node(None, start)
    end_node = Node(None, end)
    # print(f"start node: {start}")
    # print(f"end node: {end}")
    open_list = [start_node]
    closed_list = []
    while open_list:
        current_node = min(open_list, key=lambda node: node.f)
        open_list.remove(current_node)
        closed_list.append(current_node)

        if current_node == end_node:
            path = []
            current = current_node
            while current:
                path.append(current.position)
                current = current.parent
            return path[::-1]

        for move in [(0, -1), (0, 1), (-1, 0), (1, 0),
                     (-1, -1), (-1, 1), (1, -1), (1, 1)]:
            node_position = (current_node.position[0] + move[0], current_node.position[1] + move[1])

            if not (0 <= node_position[0] < len(maze)) or not (0 <= node_position[1] < len(maze[0])):
                continue
            if maze[node_position[0]][node_position[1]] != 0:
                continue

            new_node = Node(current_node, node_position)

            if new_node in closed_list:
                continue

            new_node.g = current_node.g + 1
            new_node.h = (new_node.position[0] - end_node.position[0]) ** 2 + \
                         (new_node.position[1] - end_node.position[1]) ** 2
            new_node.f = new_node.g + new_node.h

            if any(open_node for open_node in open_list if new_node == open_node and new_node.g > open_node.g):
                continue

            open_list.append(new_node)

def print_map(matrix, start, end, path):
    rows, cols = len(matrix), len(matrix[0])
    map_to_print = [['â¬œ' if cell == 0 else 'â¬›' for cell in row] for row in matrix]

    if path:
        for pos in path:
            if pos != start and pos != end:
                map_to_print[pos[0]][pos[1]] = 'ðŸŸ¦'

    map_to_print[start[0]][start[1]] = 'ðŸŸ©'
    map_to_print[end[0]][end[1]] = 'ðŸŸ¥'

    for row in map_to_print:
        print(''.join(row))

if is_google_colab():
    # Now try A* execution on random points
    free_coords = list(zip(*np.where(traversable_grid_2 == 0)))
    start, end = random.sample(free_coords, 2)

    # good example for start-end coordinates:
    # Start: (np.int64(37), np.int64(30))
    # End: (np.int64(23), np.int64(39))

    path = astar(traversable_grid_2.tolist(), start, end)

    print("Start:", start)
    print("End:", end)
    print_map(traversable_grid_2.tolist(), start, end, path)

"""## RRT*"""

# Minimal Node class for grid-based RRT*
class RRTNode:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.parent = None
        self.cost = 0

class GridRRTStar:
    def __init__(self, grid, start, goal, step_size=1.0, max_iter=1000):
        self.grid = grid
        self.rows, self.cols = grid.shape
        self.start = RRTNode(*start[::-1])
        self.goal = RRTNode(*goal[::-1])
        self.step_size = step_size
        self.max_iter = max_iter
        self.node_list = [self.start]
        self.goal_radius = 5.0
        self.search_radius = 4.0
        self.path = None

    def is_free(self, x, y):
        return 0 <= x < self.cols and 0 <= y < self.rows and self.grid[y, x] == 0

    def get_random_node(self):
        if random.random() > 0.2:
            x = random.randint(0, self.cols - 1)
            y = random.randint(0, self.rows - 1)
            while not self.is_free(x, y):
                x = random.randint(0, self.cols - 1)
                y = random.randint(0, self.rows - 1)
            return RRTNode(x, y)
        else:
            return self.goal

    def get_nearest_node(self, rand_node):
        return min(self.node_list, key=lambda node: (node.x - rand_node.x)**2 + (node.y - rand_node.y)**2)

    def steer(self, from_node, to_node):
        dx = to_node.x - from_node.x
        dy = to_node.y - from_node.y
        dist = math.hypot(dx, dy)
        if dist == 0:
            return None
        nx = int(from_node.x + self.step_size * dx / dist)
        ny = int(from_node.y + self.step_size * dy / dist)
        if not self.is_free(nx, ny):
            return None
        new_node = RRTNode(nx, ny)
        new_node.cost = from_node.cost + 1
        new_node.parent = from_node
        return new_node

    def find_neighbors(self, new_node):
        return [node for node in self.node_list
                if math.hypot(node.x - new_node.x, node.y - new_node.y) < self.search_radius]

    def choose_parent(self, neighbors, nearest_node, new_node):
        min_cost = nearest_node.cost + 1
        best_node = nearest_node
        for neighbor in neighbors:
            if self.is_free(neighbor.x, neighbor.y):
                cost = neighbor.cost + 1
                if cost < min_cost:
                    best_node = neighbor
                    min_cost = cost
        new_node.cost = min_cost
        new_node.parent = best_node
        return new_node

    def rewire(self, new_node, neighbors):
        for neighbor in neighbors:
            cost = new_node.cost + 1
            if cost < neighbor.cost:
                neighbor.parent = new_node
                neighbor.cost = cost

    def reached_goal(self, node):
        return math.hypot(node.x - self.goal.x, node.y - self.goal.y) < self.goal_radius

    def generate_path(self, node):
        path = []
        while node:
            path.append((node.y, node.x))  # reverse x/y for row/col
            node = node.parent
        return path[::-1]

    def plan(self):
        for _ in range(self.max_iter):
            rand_node = self.get_random_node()
            nearest_node = self.get_nearest_node(rand_node)
            new_node = self.steer(nearest_node, rand_node)
            if new_node is None:
                continue
            neighbors = self.find_neighbors(new_node)
            new_node = self.choose_parent(neighbors, nearest_node, new_node)
            self.node_list.append(new_node)
            self.rewire(new_node, neighbors)
            if self.reached_goal(new_node):
                self.path = self.generate_path(new_node)
                return self.path
        return None


if is_google_colab():
    # Reuse free space sampling from before
    free_coords = list(zip(*np.where(traversable_grid_2 == 0)))
    #start_rrt, end_rrt = random.sample(free_coords, 2)

    # Run RRT*
    rrt = GridRRTStar(traversable_grid_2, start, end)
    rrt_path = rrt.plan()

    # Visual print like A*
    print("RRT* Start:", start)
    print("RRT* End:", end)
    print_map(traversable_grid_2.tolist(), start, end, rrt_path)

"""## D*"""

# D* Lite is complex, so we'll use a simplified grid version based on dynamic replanning
# We'll implement it assuming static grid just to simulate different behavior for now



class DStarLite:
    def __init__(self, grid, start, goal):
        self.grid = grid
        self.start = start
        self.goal = goal
        self.rows, self.cols = grid.shape
        self.rhs = {}
        self.g = {}
        self.U = []
        self.km = 0
        self.init_values()

    def init_values(self):
        for y in range(self.rows):
            for x in range(self.cols):
                self.rhs[(y, x)] = float('inf')
                self.g[(y, x)] = float('inf')
        self.rhs[self.goal] = 0
        heapq.heappush(self.U, (self.calculate_key(self.goal), self.goal))

    def heuristic(self, a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan

    def calculate_key(self, s):
        return (min(self.g[s], self.rhs[s]) + self.heuristic(self.start, s) + self.km,
                min(self.g[s], self.rhs[s]))

    def update_vertex(self, u):
        if u != self.goal:
          valid_neighbors = [self.g.get(s, float('inf')) + 1
                             for s in self.get_neighbors(u)
                             if self.is_traversable(s)]
          self.rhs[u] = min(valid_neighbors) if valid_neighbors else float('inf')

        self.U = [item for item in self.U if item[1] != u]
        if self.g[u] != self.rhs[u]:
            heapq.heappush(self.U, (self.calculate_key(u), u))

    def get_neighbors(self, pos):
        y, x = pos
        return [(y+dy, x+dx) for dy, dx in [(-1,0),(1,0),(0,-1),(0,1)]
                if 0 <= y+dy < self.rows and 0 <= x+dx < self.cols]

    def is_traversable(self, pos):
        return self.grid[pos] == 0

    def compute_shortest_path(self):
        while self.U and (self.U[0][0] < self.calculate_key(self.start) or self.rhs[self.start] != self.g[self.start]):
            k_old, u = heapq.heappop(self.U)
            k_new = self.calculate_key(u)
            if k_old < k_new:
                heapq.heappush(self.U, (k_new, u))
            elif self.g[u] > self.rhs[u]:
                self.g[u] = self.rhs[u]
                for s in self.get_neighbors(u):
                    self.update_vertex(s)
            else:
                self.g[u] = float('inf')
                self.update_vertex(u)
                for s in self.get_neighbors(u):
                    self.update_vertex(s)

    def reconstruct_path(self):
        path = [self.start]
        current = self.start
        while current != self.goal:
            neighbors = self.get_neighbors(current)
            current = min(
                (n for n in neighbors if self.is_traversable(n)),
                key=lambda s: self.g.get(s, float('inf')),
                default=None
            )
            if current is None or self.g[current] == float('inf'):
                return []  # no path
            path.append(current)
        return path

if is_google_colab():
    # Instantiate and run
    dstar = DStarLite(traversable_grid_2, start, end)
    dstar.compute_shortest_path()
    dstar_path = dstar.reconstruct_path()

    # Visualize D* path on text map
    print("D* Start:", start)
    print("D* End:", end)
    print_map(traversable_grid_2.tolist(), start, end, dstar_path)

"""## Comparison different path planning strategies"""

def draw_path_on_map(image, path, color=(0, 255, 0), resolution=10):
    """Draws a path on the map image using rectangles."""
    for y, x in path:
        top_left = (x * resolution, y * resolution)
        bottom_right = (top_left[0] + resolution - 1, top_left[1] + resolution - 1)
        cv2.rectangle(image, top_left, bottom_right, color, thickness=-1)
    return image

if is_google_colab():
    # Create new overlays for A*, RRT*, and D* using color-coded paths
    overlay_astar = cv2.cvtColor(map_img, cv2.COLOR_GRAY2BGR)
    overlay_rrt = overlay_astar.copy()
    overlay_dstar = overlay_astar.copy()

    # Draw all paths
    astar_overlay = draw_path_on_map(overlay_astar, path, color=(0, 255, 0))       # Green for A*
    rrt_overlay   = draw_path_on_map(overlay_rrt, rrt_path, color=(255, 0, 0))      # Blue for RRT*
    dstar_overlay = draw_path_on_map(overlay_dstar, dstar_path, color=(0, 255, 255)) # Yellow for D*

    # Stack all three for visual comparison
    comparison = np.hstack((astar_overlay, rrt_overlay, dstar_overlay))

    # Display
    plt.figure(figsize=(24, 8))
    plt.title("A* (Green) vs RRT* (Blue) vs D* (Yellow)")
    plt.imshow(cv2.cvtColor(comparison, cv2.COLOR_BGR2RGB))
    plt.axis("off")
    plt.show()

"""| Algorithm | Behavior                                                 |
| --------- | -------------------------------------------------------- |
| **A\***   | Straightforward and optimal on the known grid            |
| **RRT\*** | Sparse and indirect, typical for randomized planners     |
| **D\***   | Path similar to A\*, but capable of efficient replanning |

### ðŸŸ¢ A* (Green, Left)
Path: Straight diagonal line through the open space

Behavior: Follows an optimal path on a grid using the shortest known cost (usually with 8-directional moves)

Strengths:

Deterministic

Guarantees shortest path (on grid)

Very efficient in static environments

Limitations:

Constrained by grid resolution

Path may appear jagged unless post-processed

### ðŸ”µ RRT* (Middle)
Path: Scattered sequence of waypoints across the free space

Behavior: Builds a tree from the start via random sampling, connecting to the goal if a safe path is found

Strengths:

Good in high-dimensional or complex spaces

Works even with kinematic constraints

Limitations:

Non-deterministic

Requires many samples for optimality

Resulting path is less smooth without smoothing or post-processing

### ðŸŸ¡ D* (Right)
Path: Zig-zag route taking long horizontal and vertical strides

Behavior: Similar to A* in structure, but designed for dynamic replanning (i.e., efficient updates when obstacles change)

Strengths:

Excellent in dynamic or partially known maps

Efficient for robot navigation in changing environments

Limitations:

Slightly more complex to implement than A*

Path shape depends on current g-values and may not appear intuitive


"""

# Compute path lengths (count of steps for A*, Euclidean for RRT*)
def euclidean_path_length(path):
    return sum(
        math.hypot(x2 - x1, y2 - y1)
        for (y1, x1), (y2, x2) in zip(path[:-1], path[1:])
    )

if is_google_colab():
    # Re-run A* to define a_path again, using the same start and end as RRT*
    a_path = astar(traversable_grid_2.tolist(), start, end)

    # Now re-calculate lengths
    astar_length = len(a_path) if a_path else 0
    rrt_length = euclidean_path_length(rrt_path) if rrt_path else 0

    astar_length, round(rrt_length, 2)


    astar_length = len(a_path) if a_path else 0
    rrt_length = euclidean_path_length(rrt_path) if rrt_path else 0
    dstar_length = len(dstar_path) if dstar_path else 0

    print("A* length:", astar_length)
    print("RRT* length:", round(rrt_length, 2))
    print("D* length:", dstar_length)

"""## RRT* tree exploration"""

# Final patched VisualRRT that includes explicit connection to the goal node
class VisualRRT(GridRRTStar):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.edges = []

    def plan_with_recording(self):
        for _ in range(self.max_iter):
            rand_node = self.get_random_node()
            nearest_node = self.get_nearest_node(rand_node)
            new_node = self.steer(nearest_node, rand_node)
            if new_node is None:
                continue
            neighbors = self.find_neighbors(new_node)
            new_node = self.choose_parent(neighbors, nearest_node, new_node)
            self.node_list.append(new_node)
            self.edges.append((nearest_node, new_node))  # Record edge
            self.rewire(new_node, neighbors)
            if self.reached_goal(new_node):
                # Explicitly add a new goal node
                goal_node = RRTNode(self.goal.x, self.goal.y)
                goal_node.parent = new_node
                goal_node.cost = new_node.cost + math.hypot(goal_node.x - new_node.x, goal_node.y - new_node.y)
                self.edges.append((new_node, goal_node))  # Add final edge to goal
                self.path = self.generate_path(goal_node)
                return self.path
        return None

if is_google_colab():
    # Use same start/end as before
    vis_rrt = VisualRRT(traversable_grid_2, start, end, max_iter=500)
    rrt_path = vis_rrt.plan_with_recording()

    # Plot full tree with path to goal
    fig, ax = plt.subplots(figsize=(8, 8))
    ax.imshow(map_img, cmap='gray')
    ax.set_title("RRT* Tree Growth with Final Edge to Goal")
    ax.set_xlim(0, traversable_grid_2.shape[1]*10)
    ax.set_ylim(traversable_grid_2.shape[0]*10, 0)

    # Draw all tree edges
    for from_node, to_node in vis_rrt.edges:
        x1, y1 = from_node.x * 10, from_node.y * 10
        x2, y2 = to_node.x * 10, to_node.y * 10
        ax.plot([x1, x2], [y1, y2], color='blue', linewidth=0.5)

    # Mark start and goal
    sx, sy = start[1] * 10, start[0] * 10
    gx, gy = end[1] * 10, end[0] * 10
    ax.plot(sx, sy, 'go', markersize=8, label="Start")
    ax.plot(gx, gy, 'ro', markersize=8, label="Goal")
    ax.legend()

    plt.show()

